<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>SHA1 Generator</title>
  <style>
    body { font-family: "Segoe UI", Arial, sans-serif; margin: 36px auto; max-width: 760px; }
    h1 { color:#2c3e50; }
    input, button { padding:8px 12px; font-size:16px; margin-top:6px; margin-bottom:12px; width:100%; box-sizing:border-box; }
    button { background:#0078d4; color:#fff; border:none; border-radius:6px; cursor:pointer; }
    button:hover{ background:#005ea2; }
    .copy-btn{ width:auto; background:#28a745; }
    .result{ background:#f8f9fa; padding:12px; border-radius:6px; font-family:monospace; white-space:pre-wrap; }
  </style>
</head>
<body>
  <div style="margin: 10px;">
    <h1>SHA1 Generator</h1>

    <label>RSVID:</label>
    <input id="rsvid" placeholder="‰æã: 380918837">

    <label>‰ΩúÊàêÊó•ÊôÇ (Unix Œºs „Åæ„Åü„ÅØ YYYYMMDDHH24MISSUS):</label>
    <input id="timeInput" placeholder="‰æã: 1761268617679051 „Åæ„Åü„ÅØ 20251024101657679051">

    <button onclick="generateSHA1()">Generator</button>

    <div class="result" id="output"></div>
    <button id="copyBtn" class="copy-btn" style="display:none;" onclick="copySHA1()">üìã Copy SHA1</button>
  </div>
  <script>
    let lastSHA1 = "";

    function pad(n, w=2){ return n.toString().padStart(w, '0'); }

    async function generateSHA1(){
      const rsvid = document.getElementById('rsvid').value.trim();
      const timeInput = document.getElementById('timeInput').value.trim();
      const out = document.getElementById('output');
      const copyBtn = document.getElementById('copyBtn');
      out.textContent = '';
      copyBtn.style.display = 'none';
      lastSHA1 = "";

      if(!rsvid || !timeInput){
        out.textContent = '‚ö†Ô∏è RSVID v√† th·ªùi gian kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.';
        return;
      }

      let formatted = '';
      let inputType = '';

      // N·∫øu l√† Unix microseconds (15-17 ch·ªØ s·ªë)
      if(/^\d{15,17}$/.test(timeInput)){
        inputType = 'unix';
        const unixMicro = BigInt(timeInput); // d√πng BigInt ƒë·ªÉ an to√†n v·ªõi 64-bit
        // milliseconds since epoch as BigInt (floor)
        const msSinceEpoch = unixMicro / 1000n; // BigInt division -> milliseconds integer
        const microRemainder = Number(unixMicro % 1000000n); // get microsecond tail for US part

        // JST = UTC + 9 hours -> c·ªông 9*3600*1000 ms
        const jstMs = Number(msSinceEpoch) + 9 * 3600 * 1000;

        // T·∫°o Date t·ª´ jstMs BUT d√πng c√°c h√†m UTC ƒë·ªÉ ch·∫Øc ch·∫Øn kh√¥ng ph·ª• thu·ªôc timezone local
        const jstDate = new Date(jstMs);

        // L·∫•y c√°c th√†nh ph·∫ßn b·∫±ng getUTC* (v√¨ jstMs ƒë√£ l√† milliseconds cho JST)
        const Y = jstDate.getUTCFullYear();
        const M = pad(jstDate.getUTCMonth() + 1);
        const D = pad(jstDate.getUTCDate());
        const h = pad(jstDate.getUTCHours());
        const m = pad(jstDate.getUTCMinutes());
        const s = pad(jstDate.getUTCSeconds());
        const us = pad(microRemainder, 6);

        formatted = `${Y}${M}${D}${h}${m}${s}${us}`;

      // N·∫øu ƒë√£ nh·∫≠p d·∫°ng YYYYMMDDHH24MISSUS (20 ch·ªØ s·ªë)
      } else if(/^\d{20}$/.test(timeInput)){
        inputType = 'formatted';
        // Gi·ªØ nguy√™n (gi·∫£ ƒë·ªãnh user ƒë√£ nh·∫≠p JST ho·∫∑c form ƒë√∫ng)
        formatted = timeInput;
      } else {
        out.textContent = '‚ö†Ô∏è ƒê·ªãnh d·∫°ng th·ªùi gian kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p Unix Œºs (15-17 ch·ªØ s·ªë) ho·∫∑c YYYYMMDDHH24MISSUS (20 ch·ªØ s·ªë).';
        return;
      }

      const concat = rsvid + formatted;

      // T√≠nh SHA1 b·∫±ng Web Crypto API
      const encoder = new TextEncoder();
      const data = encoder.encode(concat);
      const hashBuffer = await crypto.subtle.digest('SHA-1', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map(b => b.toString(16).padStart(2,'0')).join('');

      // Hi·ªÉn th·ªã JST ƒë·ªçc ƒë∆∞·ª£c (n·∫øu input l√† formatted, ta parse; n·∫øu l√† unix, ta ƒë√£ t√≠nh JST)
      let jstReadable = '';
      if(inputType === 'formatted'){
        const y = formatted.slice(0,4);
        const mo = formatted.slice(4,6);
        const d = formatted.slice(6,8);
        const hh = formatted.slice(8,10);
        const mi = formatted.slice(10,12);
        const ss = formatted.slice(12,14);
        const usv = formatted.slice(14);
        jstReadable = `${y}-${mo}-${d} ${hh}:${mi}:${ss}.${usv} (JST Êé®ÂÆö)`;
      } else {
        // For unix path, reconstruct same as formatted for user clarity
        const y = formatted.slice(0,4);
        const mo = formatted.slice(4,6);
        const d = formatted.slice(6,8);
        const hh = formatted.slice(8,10);
        const mi = formatted.slice(10,12);
        const ss = formatted.slice(12,14);
        const usv = formatted.slice(14);
        jstReadable = `${y}-${mo}-${d} ${hh}:${mi}:${ss}.${usv} (JST)`;
      }

      out.textContent =
        `RSVID: ${rsvid}\n` +
        `‰ΩúÊàêÊó•ÊôÇ(YYYYMMDDHH24MISSUS): ${formatted}\n` +
        `JST ÊôÇÂàª: ${jstReadable}\n` +
        `ÈÄ£ÁµêÊñáÂ≠óÂàó: ${concat}\n` +
        `SHA1: ${hashHex}`;

      lastSHA1 = hashHex;
      copyBtn.style.display = 'inline-block';
    }

    async function copySHA1(){
      if(!lastSHA1) return;
      try{
        await navigator.clipboard.writeText(lastSHA1);
        const btn = document.getElementById('copyBtn');
        const old = btn.textContent;
        btn.textContent = "‚úÖ Copied!";
        setTimeout(()=> btn.textContent = old, 1400);
      } catch(e){
        alert("‚ö†Ô∏è Kh√¥ng th·ªÉ copy SHA1 v√†o clipboard.");
      }
    }
  </script>
</body>
</html>
